# Mini 语言词法分析器实验报告

---

## 实验概述

**实验名称**：Mini 语言词法分析器的设计与实现  
**实验目的**：

1. 理解词法分析在编译过程中的作用和地位
2. 掌握正规式、有限自动机等形式化方法在词法分析中的应用
3. 设计并实现一个完整的词法分析器，能够识别 Mini 语言的所有词法单元
4. 掌握词法错误检测与恢复机制
5. 学习符号表和常数表的组织与管理方法

**实验内容**：设计并实现一个 Mini 语言词法分析器，将源程序转换为 Token 序列，构建符号表和常数表，并能检测和报告词法错误。

---

## 第一部分 语言形式化描述（正规式/文法）

### 1.1 Mini 语言词汇表

Mini 语言是一个简化的类 C 语言，包含以下词法单元：

**关键字（Keywords）**：`if | else | while | int | return`

**标识符（Identifier）**：

- 以字母或下划线开头，后跟字母、数字或下划线的序列
- 正规式：`(letter | _)(letter | digit | _)*`

**常量（Constants）**：

- **整数**：`digit+`，如 `123`
- **浮点数**：`digit+ . digit+`，如 `3.14`
- **科学计数法**：`digit+ (. digit+)? (e|E) [+|-]? digit+`，如 `6.022e23`
- **字符串**：`" (\" | [^"\n])* "` 或 `' (\' | [^'\n])* '`

**运算符**：`+`, `-`, `*`, `/`, `=`, `==`, `!=`, `<`, `<=`, `>`, `>=`, `&&`, `||`, `++`, `--`

**界限符**：`(`, `)`, `{`, `}`, `;`, `,`

**注释**：

- 块注释：`/* ... */`
- 单行注释：`// ...\n`

### 1.2 词法单元的正规式定义

```
letter    → [a-z] | [A-Z]
digit     → [0-9]

关键字    → if | else | while | int | return
标识符    → (letter|_)(letter|digit|_)*
整数      → digit+
浮点数    → digit+ . digit+
科学计数法 → digit+ (. digit+)? (e|E) [+|-]? digit+
字符串    → " (\\. | [^"\n])* " | ' (\\. | [^'\n])* '
双字符运算符 → == | != | <= | >= | && | || | ++ | --
单字符运算符 → + | - | * | / | = | < | >
界限符    → ( | ) | { | } | ; | ,
块注释    → /* (.|\n)*? */
单行注释  → // [^\n]* \n
空白符    → (space | tab | newline)+
```

### 1.3 词法规则的优先级

1. **最长匹配原则**：`==` 优先于 `=`，`<=` 优先于 `<`
2. **关键字优先原则**：先检查是否为关键字
3. **前瞻原则**：需要向前看一个字符来确定 Token 边界

---

## 第二部分 单词编码表

| **类别码** | **Token 类型** | **词素示例** | **属性值** |
| :--------: | :------------- | :----------- | :--------- | --- | --- |
|     1      | IF             | `if`         | -          |
|     2      | ELSE           | `else`       | -          |
|     3      | WHILE          | `while`      | -          |
|     4      | INT            | `int`        | -          |
|     5      | RETURN         | `return`     | -          |
|     6      | PLUS           | `+`          | -          |
|     7      | MINUS          | `-`          | -          |
|     8      | MULTIPLY       | `*`          | -          |
|     9      | DIVIDE         | `/`          | -          |
|     10     | ASSIGN         | `=`          | -          |
|     11     | EQUAL          | `==`         | -          |
|     12     | NOT_EQUAL      | `!=`         | -          |
|     13     | LESS           | `<`          | -          |
|     14     | LESS_EQUAL     | `<=`         | -          |
|     15     | GREATER        | `>`          | -          |
|     16     | GREATER_EQUAL  | `>=`         | -          |
|     17     | LEFT_PAREN     | `(`          | -          |
|     18     | RIGHT_PAREN    | `)`          | -          |
|     19     | LEFT_BRACE     | `{`          | -          |
|     20     | RIGHT_BRACE    | `}`          | -          |
|     21     | SEMICOLON      | `;`          | -          |
|     22     | COMMA          | `,`          | -          |
|     23     | IDENTIFIER     | 标识符       | 符号表索引 |
|     24     | INTEGER        | 整数         | 常数表索引 |
|     26     | FLOAT          | 浮点数       | 常数表索引 |
|     27     | STRING         | 字符串       | 常数表索引 |
|     28     | EOF            | 文件结束     | -          |
|     29     | AND            | `&&`         | -          |
|     30     | OR             | `            |            | `   | -   |
|     31     | INCREMENT      | `++`         | -          |
|     32     | DECREMENT      | `--`         | -          |

**Token 输出格式**：`<类别码, '词素', Line:行号, Col:列号, Index:索引>`

---

## 第三部分 状态转换图

### 3.1 标识符和关键字识别的 DFA

```
       letter|_
S0 ──────────> S1 ─────┐
                │      │ letter|digit|_
                └──────┘
                │ other
                ▼
               [F1] 接受状态

处理：回退一个字符，检查关键字表
```

### 3.2 整数常量识别的 DFA

```
       digit
S0 ──────> S2 ─────┐
            │      │ digit
            └──────┘
            │ other
            ▼
           [F2] 接受状态（整数）
```

### 3.3 浮点数和科学计数法识别的 DFA

```
            digit
S0 ──────────> S2 ─────┐
                │      │ digit
                │      └─────
                │ .
                ▼
               S3 (小数点后)
                │ digit
                ▼
               S4 ─────┐
                │      │ digit
                │      └─────
                │ e|E
                ▼
               S5 (指数符号)
                │ +|-|digit
                ▼
               S6/S7
                │ digit
                ▼
               [F3] 接受状态（浮点数/科学计数法）
```

**关键转换**：

- S2 + `.` → S3（进入小数部分）
- S2/S4 + `e|E` → S5（进入指数部分）
- S5 + `digit` 或 S6 + `digit` → S7（读取指数数值）

### 3.4 字符串常量识别的 DFA

```
       " (或 ')
S0 ──────────> S8 ────────┐
                │         │ 非" 非\ 非换行
                │ \       │
                ▼         │
               S9 ────────┘
                │ n|t|r|"|'|\
                └─────────> S8

              S8
                │ 匹配的引号
                ▼
               [F4] 接受状态
```

**支持的转义字符**：`\n`, `\t`, `\r`, `\"`, `\'`, `\\`

### 3.5 双字符运算符识别

以 `=` 和 `==` 为例：

```
       =
S0 ──────> S10 ────┐
            │      │ =
            │      ▼
            │     [F6] ==
            │ other
            ▼
           [F5] =
```

同理适用于：`!=`, `<=`, `>=`, `&&`, `||`, `++`, `--`

### 3.6 注释识别

**块注释**：

```
       /        *
S0 ──────> S11 ──────> S12 ───┐
                       │       │ 非*
                       │ *     │
                       ▼       │
                      S13 ─────┘
                       │ /
                       ▼
                      [跳过]
```

**单行注释**：

```
       /        /
S0 ──────> S11 ──────> S14 ───┐
                       │       │ 非换行
                       └───────┘
                       │ \n
                       ▼
                      [跳过]
```

---

## 第四部分 词法分析算法

### 4.1 核心数据结构

```python
class LexicalAnalyzer:
    def __init__(self, source_code: str):
        self.source = source_code        # 源代码
        self.pos = 0                     # 当前位置
        self.line = 1                    # 当前行号
        self.column = 1                  # 当前列号
        self.current_char = source[0]    # 当前字符

        # 关键字表（哈希）
        self.keywords = {'if': 1, 'else': 2, 'while': 3, 'int': 4, 'return': 5}

        # 双字符运算符映射
        self.double_char_tokens = {
            '==': 11, '!=': 12, '<=': 14, '>=': 16,
            '&&': 29, '||': 30, '++': 31, '--': 32
        }

        # 符号表和常数表（哈希优化）
        self.symbol_table = []
        self.symbol_map = {}
        self.constant_table = []
        self.constant_map = {}
```

### 4.2 主控算法

```python
def get_next_token(self) -> Token:
    """获取下一个 Token"""
    while self.current_char:
        # 1. 跳过空白符
        if self.current_char in ' \t\n\r':
            self.skip_whitespace()
            continue

        # 2. 跳过注释
        if self.current_char == '/' and self.peek() == '*':
            self.skip_block_comment()
            continue
        if self.current_char == '/' and self.peek() == '/':
            self.skip_line_comment()
            continue

        # 3. 识别标识符/关键字
        if self.current_char.isalpha() or self.current_char == '_':
            return self.read_identifier()

        # 4. 识别数字
        if self.current_char.isdigit():
            return self.read_number()

        # 5. 识别字符串
        if self.current_char in '"\'':
            return self.read_string()

        # 6. 识别运算符（双字符优先）
        if self.current_char in '=!<>&|+-':
            return self.read_operator()

        # 7. 识别界限符
        if self.current_char in '(){}; ,*':
            return self.read_delimiter()

        # 8. 非法字符
        self.error(f"非法字符 '{self.current_char}'")
        self.advance()

    return Token(TokenType.EOF, 'EOF', self.line, self.column)
```

### 4.3 关键算法实现

#### 4.3.1 数字识别（支持科学计数法）

```python
def read_number(self) -> Token:
    """识别整数、浮点数或科学计数法"""
    result = ''
    is_float = False

    # 阶段1：读取整数和小数部分
    while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):
        if self.current_char == '.':
            if is_float or not self.peek().isdigit():
                break
            is_float = True
        result += self.current_char
        self.advance()

    # 阶段2：处理指数部分
    if self.current_char and self.current_char.lower() == 'e':
        result += self.current_char
        self.advance()

        if self.current_char in '+-':
            result += self.current_char
            self.advance()

        if not self.current_char.isdigit():
            self.error("科学计数法格式错误: 指数后缺少数字")
            return Token(TokenType.FLOAT, result, ...)

        while self.current_char and self.current_char.isdigit():
            result += self.current_char
            self.advance()

        is_float = True

    # 生成 Token
    if is_float:
        value = float(result)
        index = self.add_to_constant_table(value, "float")
        return Token(TokenType.FLOAT, result, ..., index)
    else:
        value = int(result)
        index = self.add_to_constant_table(value, "int")
        return Token(TokenType.INTEGER, result, ..., index)
```

#### 4.3.2 字符串识别（支持转义）

```python
def read_string(self) -> Token:
    """识别字符串常量"""
    quote_char = self.current_char
    self.advance()
    result = ''

    while self.current_char and self.current_char != quote_char:
        if self.current_char == '\n':
            self.error("字符串常量未闭合")
            break

        if self.current_char == '\\':
            self.advance()
            escape_map = {'n': '\n', 't': '\t', 'r': '\r', '"': '"', "'": "'", '\\': '\\'}
            result += escape_map.get(self.current_char, self.current_char)
            self.advance()
        else:
            result += self.current_char
            self.advance()

    if self.current_char == quote_char:
        self.advance()
    else:
        self.error("字符串常量未闭合")

    index = self.add_to_constant_table(result, "string")
    return Token(TokenType.STRING, result, ..., index)
```

### 4.4 符号表和常数表管理

```python
def add_to_symbol_table(self, name: str) -> int:
    """添加标识符到符号表（O(1)哈希查找）"""
    if name in self.symbol_map:
        return self.symbol_map[name]

    index = len(self.symbol_table)
    self.symbol_table.append(SymbolEntry(name, index))
    self.symbol_map[name] = index
    return index

def add_to_constant_table(self, value, const_type: str) -> int:
    """添加常量到常数表"""
    if value in self.constant_map:
        return self.constant_map[value]

    index = len(self.constant_table)
    self.constant_table.append(ConstantEntry(value, index, const_type))
    self.constant_map[value] = index
    return index
```

### 4.5 错误处理机制

```python
MAX_ERRORS = 10

def error(self, message: str):
    """报告词法错误"""
    error_msg = f"错误 (行 {self.line}, 列 {self.column}): {message}"
    self.errors.append(error_msg)
    print(error_msg)

    if len(self.errors) >= self.MAX_ERRORS:
        raise Exception("错误过多，停止编译")
```

**错误恢复策略**：

1. 跳过非法字符，继续分析
2. 保留已识别的 Token
3. 达到错误上限后停止

### 4.6 算法复杂度

- **时间复杂度**：O(N)，N 为源代码长度
- **空间复杂度**：O(M + K)，M 为标识符数，K 为常量数
- **符号表查找**：O(1)（哈希表）
- **关键字检查**：O(1)（哈希表）

---

**本报告共五部分，第五部分（测试计划）见后续章节。**
